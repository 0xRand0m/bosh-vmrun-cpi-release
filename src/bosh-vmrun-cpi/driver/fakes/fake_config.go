// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"bosh-vmrun-cpi/driver"
	"sync"
)

type FakeConfig struct {
	OvftoolPathStub        func() string
	ovftoolPathMutex       sync.RWMutex
	ovftoolPathArgsForCall []struct{}
	ovftoolPathReturns     struct {
		result1 string
	}
	ovftoolPathReturnsOnCall map[int]struct {
		result1 string
	}
	VmrunPathStub        func() string
	vmrunPathMutex       sync.RWMutex
	vmrunPathArgsForCall []struct{}
	vmrunPathReturns     struct {
		result1 string
	}
	vmrunPathReturnsOnCall map[int]struct {
		result1 string
	}
	VdiskmanagerPathStub        func() string
	vdiskmanagerPathMutex       sync.RWMutex
	vdiskmanagerPathArgsForCall []struct{}
	vdiskmanagerPathReturns     struct {
		result1 string
	}
	vdiskmanagerPathReturnsOnCall map[int]struct {
		result1 string
	}
	VmPathStub        func() string
	vmPathMutex       sync.RWMutex
	vmPathArgsForCall []struct{}
	vmPathReturns     struct {
		result1 string
	}
	vmPathReturnsOnCall map[int]struct {
		result1 string
	}
	BootstrapScriptPathStub        func() string
	bootstrapScriptPathMutex       sync.RWMutex
	bootstrapScriptPathArgsForCall []struct{}
	bootstrapScriptPathReturns     struct {
		result1 string
	}
	bootstrapScriptPathReturnsOnCall map[int]struct {
		result1 string
	}
	BootstrapScriptContentStub        func() string
	bootstrapScriptContentMutex       sync.RWMutex
	bootstrapScriptContentArgsForCall []struct{}
	bootstrapScriptContentReturns     struct {
		result1 string
	}
	bootstrapScriptContentReturnsOnCall map[int]struct {
		result1 string
	}
	BootstrapInterpreterPathStub        func() string
	bootstrapInterpreterPathMutex       sync.RWMutex
	bootstrapInterpreterPathArgsForCall []struct{}
	bootstrapInterpreterPathReturns     struct {
		result1 string
	}
	bootstrapInterpreterPathReturnsOnCall map[int]struct {
		result1 string
	}
	BootstrapUsernameStub        func() string
	bootstrapUsernameMutex       sync.RWMutex
	bootstrapUsernameArgsForCall []struct{}
	bootstrapUsernameReturns     struct {
		result1 string
	}
	bootstrapUsernameReturnsOnCall map[int]struct {
		result1 string
	}
	BootstrapPasswordStub        func() string
	bootstrapPasswordMutex       sync.RWMutex
	bootstrapPasswordArgsForCall []struct{}
	bootstrapPasswordReturns     struct {
		result1 string
	}
	bootstrapPasswordReturnsOnCall map[int]struct {
		result1 string
	}
	NeedsBootstrapStub        func() bool
	needsBootstrapMutex       sync.RWMutex
	needsBootstrapArgsForCall []struct{}
	needsBootstrapReturns     struct {
		result1 bool
	}
	needsBootstrapReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConfig) OvftoolPath() string {
	fake.ovftoolPathMutex.Lock()
	ret, specificReturn := fake.ovftoolPathReturnsOnCall[len(fake.ovftoolPathArgsForCall)]
	fake.ovftoolPathArgsForCall = append(fake.ovftoolPathArgsForCall, struct{}{})
	fake.recordInvocation("OvftoolPath", []interface{}{})
	fake.ovftoolPathMutex.Unlock()
	if fake.OvftoolPathStub != nil {
		return fake.OvftoolPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ovftoolPathReturns.result1
}

func (fake *FakeConfig) OvftoolPathCallCount() int {
	fake.ovftoolPathMutex.RLock()
	defer fake.ovftoolPathMutex.RUnlock()
	return len(fake.ovftoolPathArgsForCall)
}

func (fake *FakeConfig) OvftoolPathReturns(result1 string) {
	fake.OvftoolPathStub = nil
	fake.ovftoolPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) OvftoolPathReturnsOnCall(i int, result1 string) {
	fake.OvftoolPathStub = nil
	if fake.ovftoolPathReturnsOnCall == nil {
		fake.ovftoolPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.ovftoolPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) VmrunPath() string {
	fake.vmrunPathMutex.Lock()
	ret, specificReturn := fake.vmrunPathReturnsOnCall[len(fake.vmrunPathArgsForCall)]
	fake.vmrunPathArgsForCall = append(fake.vmrunPathArgsForCall, struct{}{})
	fake.recordInvocation("VmrunPath", []interface{}{})
	fake.vmrunPathMutex.Unlock()
	if fake.VmrunPathStub != nil {
		return fake.VmrunPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.vmrunPathReturns.result1
}

func (fake *FakeConfig) VmrunPathCallCount() int {
	fake.vmrunPathMutex.RLock()
	defer fake.vmrunPathMutex.RUnlock()
	return len(fake.vmrunPathArgsForCall)
}

func (fake *FakeConfig) VmrunPathReturns(result1 string) {
	fake.VmrunPathStub = nil
	fake.vmrunPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) VmrunPathReturnsOnCall(i int, result1 string) {
	fake.VmrunPathStub = nil
	if fake.vmrunPathReturnsOnCall == nil {
		fake.vmrunPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.vmrunPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) VdiskmanagerPath() string {
	fake.vdiskmanagerPathMutex.Lock()
	ret, specificReturn := fake.vdiskmanagerPathReturnsOnCall[len(fake.vdiskmanagerPathArgsForCall)]
	fake.vdiskmanagerPathArgsForCall = append(fake.vdiskmanagerPathArgsForCall, struct{}{})
	fake.recordInvocation("VdiskmanagerPath", []interface{}{})
	fake.vdiskmanagerPathMutex.Unlock()
	if fake.VdiskmanagerPathStub != nil {
		return fake.VdiskmanagerPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.vdiskmanagerPathReturns.result1
}

func (fake *FakeConfig) VdiskmanagerPathCallCount() int {
	fake.vdiskmanagerPathMutex.RLock()
	defer fake.vdiskmanagerPathMutex.RUnlock()
	return len(fake.vdiskmanagerPathArgsForCall)
}

func (fake *FakeConfig) VdiskmanagerPathReturns(result1 string) {
	fake.VdiskmanagerPathStub = nil
	fake.vdiskmanagerPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) VdiskmanagerPathReturnsOnCall(i int, result1 string) {
	fake.VdiskmanagerPathStub = nil
	if fake.vdiskmanagerPathReturnsOnCall == nil {
		fake.vdiskmanagerPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.vdiskmanagerPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) VmPath() string {
	fake.vmPathMutex.Lock()
	ret, specificReturn := fake.vmPathReturnsOnCall[len(fake.vmPathArgsForCall)]
	fake.vmPathArgsForCall = append(fake.vmPathArgsForCall, struct{}{})
	fake.recordInvocation("VmPath", []interface{}{})
	fake.vmPathMutex.Unlock()
	if fake.VmPathStub != nil {
		return fake.VmPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.vmPathReturns.result1
}

func (fake *FakeConfig) VmPathCallCount() int {
	fake.vmPathMutex.RLock()
	defer fake.vmPathMutex.RUnlock()
	return len(fake.vmPathArgsForCall)
}

func (fake *FakeConfig) VmPathReturns(result1 string) {
	fake.VmPathStub = nil
	fake.vmPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) VmPathReturnsOnCall(i int, result1 string) {
	fake.VmPathStub = nil
	if fake.vmPathReturnsOnCall == nil {
		fake.vmPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.vmPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BootstrapScriptPath() string {
	fake.bootstrapScriptPathMutex.Lock()
	ret, specificReturn := fake.bootstrapScriptPathReturnsOnCall[len(fake.bootstrapScriptPathArgsForCall)]
	fake.bootstrapScriptPathArgsForCall = append(fake.bootstrapScriptPathArgsForCall, struct{}{})
	fake.recordInvocation("BootstrapScriptPath", []interface{}{})
	fake.bootstrapScriptPathMutex.Unlock()
	if fake.BootstrapScriptPathStub != nil {
		return fake.BootstrapScriptPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bootstrapScriptPathReturns.result1
}

func (fake *FakeConfig) BootstrapScriptPathCallCount() int {
	fake.bootstrapScriptPathMutex.RLock()
	defer fake.bootstrapScriptPathMutex.RUnlock()
	return len(fake.bootstrapScriptPathArgsForCall)
}

func (fake *FakeConfig) BootstrapScriptPathReturns(result1 string) {
	fake.BootstrapScriptPathStub = nil
	fake.bootstrapScriptPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BootstrapScriptPathReturnsOnCall(i int, result1 string) {
	fake.BootstrapScriptPathStub = nil
	if fake.bootstrapScriptPathReturnsOnCall == nil {
		fake.bootstrapScriptPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.bootstrapScriptPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BootstrapScriptContent() string {
	fake.bootstrapScriptContentMutex.Lock()
	ret, specificReturn := fake.bootstrapScriptContentReturnsOnCall[len(fake.bootstrapScriptContentArgsForCall)]
	fake.bootstrapScriptContentArgsForCall = append(fake.bootstrapScriptContentArgsForCall, struct{}{})
	fake.recordInvocation("BootstrapScriptContent", []interface{}{})
	fake.bootstrapScriptContentMutex.Unlock()
	if fake.BootstrapScriptContentStub != nil {
		return fake.BootstrapScriptContentStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bootstrapScriptContentReturns.result1
}

func (fake *FakeConfig) BootstrapScriptContentCallCount() int {
	fake.bootstrapScriptContentMutex.RLock()
	defer fake.bootstrapScriptContentMutex.RUnlock()
	return len(fake.bootstrapScriptContentArgsForCall)
}

func (fake *FakeConfig) BootstrapScriptContentReturns(result1 string) {
	fake.BootstrapScriptContentStub = nil
	fake.bootstrapScriptContentReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BootstrapScriptContentReturnsOnCall(i int, result1 string) {
	fake.BootstrapScriptContentStub = nil
	if fake.bootstrapScriptContentReturnsOnCall == nil {
		fake.bootstrapScriptContentReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.bootstrapScriptContentReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BootstrapInterpreterPath() string {
	fake.bootstrapInterpreterPathMutex.Lock()
	ret, specificReturn := fake.bootstrapInterpreterPathReturnsOnCall[len(fake.bootstrapInterpreterPathArgsForCall)]
	fake.bootstrapInterpreterPathArgsForCall = append(fake.bootstrapInterpreterPathArgsForCall, struct{}{})
	fake.recordInvocation("BootstrapInterpreterPath", []interface{}{})
	fake.bootstrapInterpreterPathMutex.Unlock()
	if fake.BootstrapInterpreterPathStub != nil {
		return fake.BootstrapInterpreterPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bootstrapInterpreterPathReturns.result1
}

func (fake *FakeConfig) BootstrapInterpreterPathCallCount() int {
	fake.bootstrapInterpreterPathMutex.RLock()
	defer fake.bootstrapInterpreterPathMutex.RUnlock()
	return len(fake.bootstrapInterpreterPathArgsForCall)
}

func (fake *FakeConfig) BootstrapInterpreterPathReturns(result1 string) {
	fake.BootstrapInterpreterPathStub = nil
	fake.bootstrapInterpreterPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BootstrapInterpreterPathReturnsOnCall(i int, result1 string) {
	fake.BootstrapInterpreterPathStub = nil
	if fake.bootstrapInterpreterPathReturnsOnCall == nil {
		fake.bootstrapInterpreterPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.bootstrapInterpreterPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BootstrapUsername() string {
	fake.bootstrapUsernameMutex.Lock()
	ret, specificReturn := fake.bootstrapUsernameReturnsOnCall[len(fake.bootstrapUsernameArgsForCall)]
	fake.bootstrapUsernameArgsForCall = append(fake.bootstrapUsernameArgsForCall, struct{}{})
	fake.recordInvocation("BootstrapUsername", []interface{}{})
	fake.bootstrapUsernameMutex.Unlock()
	if fake.BootstrapUsernameStub != nil {
		return fake.BootstrapUsernameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bootstrapUsernameReturns.result1
}

func (fake *FakeConfig) BootstrapUsernameCallCount() int {
	fake.bootstrapUsernameMutex.RLock()
	defer fake.bootstrapUsernameMutex.RUnlock()
	return len(fake.bootstrapUsernameArgsForCall)
}

func (fake *FakeConfig) BootstrapUsernameReturns(result1 string) {
	fake.BootstrapUsernameStub = nil
	fake.bootstrapUsernameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BootstrapUsernameReturnsOnCall(i int, result1 string) {
	fake.BootstrapUsernameStub = nil
	if fake.bootstrapUsernameReturnsOnCall == nil {
		fake.bootstrapUsernameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.bootstrapUsernameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BootstrapPassword() string {
	fake.bootstrapPasswordMutex.Lock()
	ret, specificReturn := fake.bootstrapPasswordReturnsOnCall[len(fake.bootstrapPasswordArgsForCall)]
	fake.bootstrapPasswordArgsForCall = append(fake.bootstrapPasswordArgsForCall, struct{}{})
	fake.recordInvocation("BootstrapPassword", []interface{}{})
	fake.bootstrapPasswordMutex.Unlock()
	if fake.BootstrapPasswordStub != nil {
		return fake.BootstrapPasswordStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bootstrapPasswordReturns.result1
}

func (fake *FakeConfig) BootstrapPasswordCallCount() int {
	fake.bootstrapPasswordMutex.RLock()
	defer fake.bootstrapPasswordMutex.RUnlock()
	return len(fake.bootstrapPasswordArgsForCall)
}

func (fake *FakeConfig) BootstrapPasswordReturns(result1 string) {
	fake.BootstrapPasswordStub = nil
	fake.bootstrapPasswordReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BootstrapPasswordReturnsOnCall(i int, result1 string) {
	fake.BootstrapPasswordStub = nil
	if fake.bootstrapPasswordReturnsOnCall == nil {
		fake.bootstrapPasswordReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.bootstrapPasswordReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) NeedsBootstrap() bool {
	fake.needsBootstrapMutex.Lock()
	ret, specificReturn := fake.needsBootstrapReturnsOnCall[len(fake.needsBootstrapArgsForCall)]
	fake.needsBootstrapArgsForCall = append(fake.needsBootstrapArgsForCall, struct{}{})
	fake.recordInvocation("NeedsBootstrap", []interface{}{})
	fake.needsBootstrapMutex.Unlock()
	if fake.NeedsBootstrapStub != nil {
		return fake.NeedsBootstrapStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.needsBootstrapReturns.result1
}

func (fake *FakeConfig) NeedsBootstrapCallCount() int {
	fake.needsBootstrapMutex.RLock()
	defer fake.needsBootstrapMutex.RUnlock()
	return len(fake.needsBootstrapArgsForCall)
}

func (fake *FakeConfig) NeedsBootstrapReturns(result1 bool) {
	fake.NeedsBootstrapStub = nil
	fake.needsBootstrapReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) NeedsBootstrapReturnsOnCall(i int, result1 bool) {
	fake.NeedsBootstrapStub = nil
	if fake.needsBootstrapReturnsOnCall == nil {
		fake.needsBootstrapReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.needsBootstrapReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.ovftoolPathMutex.RLock()
	defer fake.ovftoolPathMutex.RUnlock()
	fake.vmrunPathMutex.RLock()
	defer fake.vmrunPathMutex.RUnlock()
	fake.vdiskmanagerPathMutex.RLock()
	defer fake.vdiskmanagerPathMutex.RUnlock()
	fake.vmPathMutex.RLock()
	defer fake.vmPathMutex.RUnlock()
	fake.bootstrapScriptPathMutex.RLock()
	defer fake.bootstrapScriptPathMutex.RUnlock()
	fake.bootstrapScriptContentMutex.RLock()
	defer fake.bootstrapScriptContentMutex.RUnlock()
	fake.bootstrapInterpreterPathMutex.RLock()
	defer fake.bootstrapInterpreterPathMutex.RUnlock()
	fake.bootstrapUsernameMutex.RLock()
	defer fake.bootstrapUsernameMutex.RUnlock()
	fake.bootstrapPasswordMutex.RLock()
	defer fake.bootstrapPasswordMutex.RUnlock()
	fake.needsBootstrapMutex.RLock()
	defer fake.needsBootstrapMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConfig) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ driver.Config = new(FakeConfig)
